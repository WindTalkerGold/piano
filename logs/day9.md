### **第九天：探索音色与自动化——在AI的效率与技术的现实边界之间**

第九天，我为这个已经能“看”和“听”的钢琴学习应用设定了两个新的进阶目标：**让体验更自动化，让声音更多元**。

**目标一：乐谱自动滚动（快速实现与经典的“选择器”陷阱）**

第一个功能非常直观：在播放时，当光标移动到乐谱可视区域底部附近时，页面应自动平滑地向上滚动，实现“自动翻页”，避免手动拖拽。我将这个描述交给了Claude Code。

AI几乎立刻响应，生成了完整的实现代码。逻辑清晰：监听光标的`Y`坐标，当其超过某个阈值时，触发乐谱容器的滚动。从算法上看，它完全正确。

然而，运行后功能却毫无反应。经典的“最后一英里”问题再次出现。我检查代码，立刻发现了问题所在：AI写的代码中，有一行是 `document.querySelector('.cursor')`，意图获取光标DOM元素。但根据我们第八天解决的样式问题，我非常清楚地记得，那个动态生成的光标元素**根本没有 `.cursor` 这个CSS类**，它使用的是 `id` 或其他属性。

**人工干预点**：我无需深入调试，凭借对项目现状的清晰记忆，直接向AI指出了这个确切的、低级的“选择器错误”。AI迅速道歉并更正了代码，将选择器修改为正确的 `id`。修正后，**自动滚动功能完美运行**。这再次证明，AI能构建逻辑骨架，但对项目中那些具体、琐碎且动态的“事实”（比如一个元素的精确ID），缺乏连续的认知，必须由开发者——这个项目的“活字典”——来提供和校准。

**目标二：切换乐器音色（撞上“付费墙”的现实）**

第二个功能更具创意：能否让同一份乐谱不再仅仅是钢琴声，而是可以用小提琴、吉他甚至交响乐队的音色来播放？

AI对此给出了一个在技术上完全正确的方向：**使用SoundFont（.sf2）音色库文件**。它解释道，我们的播放器可以通过加载不同的SoundFont来切换乐器，并生成了相应的代码修改，试图在播放器中增加一个音色选择下拉框。

但无论我们如何调整代码，音色切换都没有任何效果。音乐依然只是钢琴声。我感到困惑，于是决定暂时跳出与AI的对话循环，**亲自去审视我们正在使用的 `opensheetmusicdisplay` 库的官方文档和示例**。

真相很快浮出水面。我发现，这个库的乐谱渲染与音频播放是分离的。它自带的默认播放器非常简单，而**高级的、支持实时加载和切换SoundFont的音频引擎，是其一项“高级特性”**。在官方GitHub仓库和示例中明确指出，要使用这个功能，需要成为其`Sponsor`（赞助者），费用大约是每月19美元。

**人工决策点**：面对这个“付费墙”，我做出了一个务实的项目决策：**将此功能搁置**。这并不是技术上的失败，而是对项目范围和资源的一次清晰界定。对于当前“为儿子练习钢琴”的核心目标来说，钢琴音色已经足够。更丰富的音色是一个“锦上添花”的扩展项，其实现成本（无论是每月订阅费还是集成官方高级API的复杂度）超出了当前版本的优先级。

**小结：满意于AI带来的效率飞跃**
尽管第二个目标因外部限制而暂停，但我对这一天的工作非常满意。AI在第一个功能上展现的效率是实实在在的：它在一个小时内就搭建出了我需要花更长时间去研究和调试的自动滚动逻辑。那个“选择器bug”只是一个需要我花10秒钟去纠正的小细节。

这一天强化了我两个认知：
1.  **AI是强大的“逻辑实现者”**：对于有明确输入输出和算法描述的功能（如“根据坐标触发滚动”），它能极快地产出可用代码，大幅提升开发速度。
2.  **开发者是关键的“上下文校准者”与“边界定义者”**：AI不知道你的光标元素到底叫什么，也不了解你所用的第三方库的商业模式。开发者需要提供精确的上下文来修正前者，并基于项目实际情况，理智地判断和定义技术的可行边界在哪里。

至此，应用的核心体验已趋于完善。自动滚动让长时间乐谱的播放练习变得流畅，而探索多种音色的过程，虽然暂停，却清晰地标出了项目未来可能延伸的一个方向。